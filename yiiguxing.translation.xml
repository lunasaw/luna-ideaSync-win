<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="439" />
    <option name="newTranslationDialogWidth" value="1272" />
    <option name="newTranslationDialogX" value="168" />
    <option name="newTranslationDialogY" value="25" />
    <histories>
      <item value="If true then resolve the class" />
      <item value="To compare elapsed time against a timeout, use" />
      <item value="Returns the current value of the running Java Virtual Machine's high-resolution time source, in nanoseconds. This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time. The value returned represents nanoseconds since some fixed but arbitrary origin time (perhaps in the future, so values may be negative). The same origin is used by all invocations of this method in an instance of a Java virtual machine; other virtual machine instances are likely to use a different origin." />
      <item value="If a security manager is present, and the caller's class loader is not {@code null}, and the caller's class loader is not the same as or an ancestor of the platform class loader, and the caller does not have the" />
      <item value="The name of the builtin platform class loader is" />
      <item value="Return the default ClassLoader to use: typically the thread context ClassLoader, if available; the ClassLoader that loaded the ClassUtils class will be used as fallback. &lt;p&gt;Call this method if you intend to use the thread context ClassLoader in a scenario where you clearly prefer a non-null ClassLoader reference: for example, for class path resource loading (but not necessarily for {@code Class.forName}, which accepts a {@code null} ClassLoader" />
      <item value="Return the default ClassLoader to use: typically the thread context ClassLoader, if available; the ClassLoader that loaded the ClassUtils class will be used as fallback. &lt;p&gt;Call this method if you intend to use the thread context ClassLoader in a scenario where you clearly prefer a non-null ClassLoader reference: for example, for class path resource loading (but not necessarily for" />
      <item value="Cannot access system ClassLoader - oh well, maybe the caller can live with null..." />
      <item value="Cannot access thread context ClassLoader - falling back..." />
      <item value="Tell the subclass to refresh the internal bean factory." />
      <item value="Prepare this context for refreshing." />
      <item value="instead" />
      <item value="occurred evaluating" />
      <item value="true if the permit was acquired, false otherwise" />
      <item value="Return whether this helper will validate all addresses passed to it." />
      <item value="It is important to note that the number of permits requested never affect the throttling of the request itself (an invocation to acquire(1) and an invocation to acquire(1000) will result in exactly the same throttling, if any), but it affects the throttling of the next request. I.e., if an expensive task arrives at an idle RateLimiter, it will be granted immediately, but it is the next request that will experience extra throttling, thus paying for the cost of the expensive task." />
      <item value="the duration of the period where the RateLimiter ramps up its rate, before reaching its stable (maximum) rate" />
      <item value="the rate of the returned RateLimiter, measured in how many permits become available per second" />
      <item value="Set multiple keys to multiple values, only if none of the keys exist with pipelining. Cross-slot keys will result in multiple calls to the particular cluster nodes." />
      <item value="Set multiple keys to multiple values with pipelining. Cross-slot keys will result in multiple calls to the particular cluster nodes." />
      <item value="Loads a new value for key, possibly asynchronously. While the new value is loading the previous value (if any) will continue to be returned by get(key) unless it is evicted. If the new value is loaded successfully it will replace the previous value in the cache; if an exception is thrown while refreshing the previous value will remain, and the exception will be logged (using java.util.logging.Logger) and swallowed." />
      <item value="Returns the value associated with key in this cache, first loading that value if necessary. No observable state associated with this cache is modified until loading completes. Unlike get, this method does not throw a checked exception, and thus should only be used in situations where checked exceptions are not thrown by the cache loader." />
      <item value="Dummy value to associate with an Object in the backing Map" />
      <item value="Creates a Spliterator over the elements described by this Iterable. Returns: a Spliterator over the elements described by this Iterable. Implementation Requirements: The default implementation creates an early-binding spliterator from the iterable's Iterator. The spliterator inherits the fail-fast properties of the iterable's iterator. Implementation Note: The default implementation should usually be overridden. The spliterator returned by the default implementation has poor splitting capabilities, is unsized, and does not report any spliterator characteristics. Implementing classes can nearly always provide a better implementation. Since: 1.8" />
      <item value="the period between successive executions" />
      <item value="the time to delay first execution" />
      <item value="Call on the superclass's implementations of {@code equals} and {@code hashCode} before calculating for the fields in this class. &lt;strong&gt;default: false&lt;strong&gt;" />
      <item value="This annotation has been deprecated as of the 3.0.1 release. @EnableDiscoveryClient is no longer needed, discovery client implementations are enabled as long as an implementation is on the classpath. @EnableCircuitBreaker is no longer used now that Hystrix has been removed from Spring Cloud." />
      <item value="Assembly" />
      <item value="Delegation to parent with explicit args" />
      <item value="arguments to use if creating a prototype using explicit arguments" />
      <item value="If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null. If the function returns null no mapping is recorded. If the function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:" />
      <item value="recommend source admin" />
      <item value="the array into which the elements of this list are to be stored, if it is big enough; otherwise, a new array of the same runtime type is allocated for this purpose." />
      <item value="all other fields defaulted" />
      <item value="if true, don't change existing value evict – if false, the table is in creation mode." />
      <item value="Special EventExecutorGroup which allows registering Channels that get processed for later selection during the event loop." />
      <item value="Trim trailing whitespace from the given {@code String}." />
      <item value="Trim leading whitespace from the given {@code String}." />
      <item value="Returns the canonical pathname string of this abstract pathname." />
      <item value="Performs the given action for each remaining element until all elements have been processed or the action throws an exception. Actions are performed in the order of iteration, if that order is specified. Exceptions thrown by the action are relayed to the caller." />
      <item value="The length of the array is the number of methods on the execution stack. The element at index 0 is the class of the currently executing method, the element at index 1 is the class of that method's caller, and so on." />
      <item value="Returns the current execution stack as an array of classes." />
      <item value="if true, then the String will be added to the end of the file rather than overwriting" />
      <item value="Defines zero (0) or more exception classes, which must be subclasses of Throwable, indicating which exception types must cause a transaction rollback. By default, a transaction will be rolled back on RuntimeException and Error but not on checked exceptions (business exceptions). See org.springframework.transaction.interceptor.DefaultTransactionAttribute.rollbackOn(Throwable) for a detailed explanation. This is the preferred way to construct a rollback rule (in contrast to rollbackForClassName), matching the exception type, its subclasses, and its nested classes. See the class-level javadocs for further details on rollback rule semantics and warnings regarding possible unintentional matches." />
      <item value="Defines zero (0) or more exception classes, which must be subclasses of Throwable, indicating which exception types must cause a transaction rollback. By default, a transaction will be rolled back on RuntimeException and Error but not on checked exceptions (business exceptions). See org.springframework.transaction.interceptor.DefaultTransactionAttribute.rollbackOn(Throwable) for a detailed explanation." />
      <item value="Copyright 2002-2022 the original author or authors. Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at https:www.apache.orglicensesLICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. package org.springframework.transaction.annotation; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Inherited; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import org.springframework.core.annotation.AliasFor; import org.springframework.transaction.TransactionDefinition; Describes a transaction attribute on an individual method or on a class. &lt;p&gt;When this annotation is declared at the class level, it applies as a default to all methods of the declaring class and its subclasses. Note that it does not apply to ancestor classes up the class hierarchy; inherited methods need to be locally redeclared in order to participate in a subclass-level annotation. For details on method visibility constraints, consult the &lt;a href=&quot;https:docs.spring.iospring-frameworkdocscurrentreferencehtmldata-access.htmltransaction&quot;&gt;Transaction Management&lt;a&gt; section of the reference manual. &lt;p&gt;This annotation is generally directly comparable to Spring's {@link org.springframework.transaction.interceptor.RuleBasedTransactionAttribute} class, and in fact {@link AnnotationTransactionAttributeSource} will directly convert this annotation's attributes to properties in {@code RuleBasedTransactionAttribute}, so that Spring's transaction support code does not have to know about annotations. &lt;h3&gt;Attribute Semantics&lt;h3&gt; &lt;p&gt;If no custom rollback rules are configured in this annotation, the transaction will roll back on {@link RuntimeException} and {@link Error} but not on checked exceptions. &lt;p&gt;Rollback rules determine if a transaction should be rolled back when a given exception is thrown, and the rules are based on patterns. A pattern can be a fully qualified class name or a substring of a fully qualified class name for an exception type (which must be a subclass of {@code Throwable}), with no wildcard support at present. For example, a value of {@code &quot;javax.servlet.ServletException&quot;} or {@code &quot;ServletException&quot;} will match {@code javax.servlet.ServletException} and its subclasses. &lt;p&gt;Rollback rules may be configured via {@link rollbackFor}{@link noRollbackFor} and {@link rollbackForClassName}{@link noRollbackForClassName}, which allow patterns to be specified as {@link Class} references or {@linkplain String strings}, respectively. When an exception type is specified as a class reference its fully qualified name will be used as the pattern. Consequently, {@code @Transactional(rollbackFor = example.CustomException.class)} is equivalent to {@code @Transactional(rollbackForClassName = &quot;example.CustomException&quot;)}. &lt;p&gt;&lt;strong&gt;WARNING:&lt;strong&gt; You must carefully consider how specific the pattern is and whether to include package information (which isn't mandatory). For example, {@code &quot;Exception&quot;} will match nearly anything and will probably hide other rules. {@code &quot;java.lang.Exception&quot;} would be correct if {@code &quot;Exception&quot;} were meant to define a rule for all checked exceptions. With more unique exception names such as {@code &quot;BaseBusinessException&quot;} there is likely no need to use the fully qualified class name for the exception pattern. Furthermore, rollback rules may result in unintentional matches for similarly named exceptions and nested classes. This is due to the fact that a thrown exception is considered to be a match for a given rollback rule if the name of thrown exception contains the exception pattern configured for the rollback rule. For example, given a rule configured to match on {@code com.example.CustomException}, that rule would match against an exception named {@code com.example.CustomExceptionV2} (an exception in the same package as {@code CustomException} but with an additional suffix) or an exception named {@code com.example.CustomExceptionAnotherException} (an exception declared as a nested class in {@code CustomException}). &lt;p&gt;For specific information about the semantics of other attributes in this annotation, consult the {@link org.springframework.transaction.TransactionDefinition} and {@link org.springframework.transaction.interceptor.TransactionAttribute} javadocs. &lt;h3&gt;Transaction Management&lt;h3&gt; &lt;p&gt;This annotation commonly works with thread-bound transactions managed by a {@link org.springframework.transaction.PlatformTransactionManager}, exposing a transaction to all data access operations within the current execution thread. &lt;b&gt;Note: This does NOT propagate to newly started threads within the method.&lt;b&gt; &lt;p&gt;Alternatively, this annotation may demarcate a reactive transaction managed by a {@link org.springframework.transaction.ReactiveTransactionManager} which uses the Reactor context instead of thread-local variables. As a consequence, all participating data access operations need to execute within the same Reactor context in the same reactive pipeline. @author Colin Sampaleanu @author Juergen Hoeller @author Sam Brannen @author Mark Paluch @since 1.2 @see org.springframework.transaction.interceptor.TransactionAttribute @see org.springframework.transaction.interceptor.DefaultTransactionAttribute @see org.springframework.transaction.interceptor.RuleBasedTransactionAttribute @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface Transactional { Alias for {@link transactionManager}. @see transactionManager @AliasFor(&quot;transactionManager&quot;) String value() default &quot;&quot;; A &lt;em&gt;qualifier&lt;em&gt; value for the specified transaction. &lt;p&gt;May be used to determine the target transaction manager, matching the qualifier value (or the bean name) of a specific {@link org.springframework.transaction.TransactionManager TransactionManager} bean definition. @since 4.2 @see value @see org.springframework.transaction.PlatformTransactionManager @see org.springframework.transaction.ReactiveTransactionManager @AliasFor(&quot;value&quot;) String transactionManager() default &quot;&quot;; Defines zero (0) or more transaction labels. &lt;p&gt;Labels may be used to describe a transaction, and they can be evaluated by individual transaction managers. Labels may serve a solely descriptive purpose or map to pre-defined transaction manager-specific options. &lt;p&gt;See the documentation of the actual transaction manager implementation for details on how it evaluates transaction labels. @since 5.3 @see org.springframework.transaction.interceptor.DefaultTransactionAttributegetLabels() String[] label() default {}; The transaction propagation type. &lt;p&gt;Defaults to {@link PropagationREQUIRED}. @see org.springframework.transaction.interceptor.TransactionAttributegetPropagationBehavior() Propagation propagation() default Propagation.REQUIRED; The transaction isolation level. &lt;p&gt;Defaults to {@link IsolationDEFAULT}. &lt;p&gt;Exclusively designed for use with {@link PropagationREQUIRED} or {@link PropagationREQUIRES_NEW} since it only applies to newly started transactions. Consider switching the &quot;validateExistingTransactions&quot; flag to &quot;true&quot; on your transaction manager if you'd like isolation level declarations to get rejected when participating in an existing transaction with a different isolation level. @see org.springframework.transaction.interceptor.TransactionAttributegetIsolationLevel() @see org.springframework.transaction.support.AbstractPlatformTransactionManagersetValidateExistingTransaction Isolation isolation() default Isolation.DEFAULT; The timeout for this transaction (in seconds). &lt;p&gt;Defaults to the default timeout of the underlying transaction system. &lt;p&gt;Exclusively designed for use with {@link PropagationREQUIRED} or {@link PropagationREQUIRES_NEW} since it only applies to newly started transactions. @return the timeout in seconds @see org.springframework.transaction.interceptor.TransactionAttributegetTimeout() int timeout() default TransactionDefinition.TIMEOUT_DEFAULT; The timeout for this transaction (in seconds). &lt;p&gt;Defaults to the default timeout of the underlying transaction system. &lt;p&gt;Exclusively designed for use with {@link PropagationREQUIRED} or {@link PropagationREQUIRES_NEW} since it only applies to newly started transactions. @return the timeout in seconds as a String value, e.g. a placeholder @since 5.3 @see org.springframework.transaction.interceptor.TransactionAttributegetTimeout() String timeoutString() default &quot;&quot;; A boolean flag that can be set to {@code true} if the transaction is effectively read-only, allowing for corresponding optimizations at runtime. &lt;p&gt;Defaults to {@code false}. &lt;p&gt;This just serves as a hint for the actual transaction subsystem; it will &lt;i&gt;not necessarily&lt;i&gt; cause failure of write access attempts. A transaction manager which cannot interpret the read-only hint will &lt;i&gt;not&lt;i&gt; throw an exception when asked for a read-only transaction but rather silently ignore the hint. @see org.springframework.transaction.interceptor.TransactionAttributeisReadOnly() @see org.springframework.transaction.support.TransactionSynchronizationManagerisCurrentTransactionReadOnly() boolean readOnly() default false; Defines zero (0) or more exception {@linkplain Class classes}, which must be subclasses of {@link Throwable}, indicating which exception types must cause a transaction rollback. &lt;p&gt;By default, a transaction will be rolled back on {@link RuntimeException} and {@link Error} but not on checked exceptions (business exceptions). See {@link org.springframework.transaction.interceptor.DefaultTransactionAttributerollbackOn(Throwable)} for a detailed explanation. &lt;p&gt;This is the preferred way to construct a rollback rule (in contrast to {@link rollbackForClassName}), matching the exception type, its subclasses, and its nested classes. See the {@linkplain Transactional class-level javadocs} for further details on rollback rule semantics and warnings regarding possible unintentional matches. @see rollbackForClassName @see org.springframework.transaction.interceptor.RollbackRuleAttributeRollbackRuleAttribute(Class) @see org.springframework.transaction.interceptor.DefaultTransactionAttributerollbackOn(Throwable) Class&lt;? extends Throwable&gt;[] rollbackFor() default {}; Defines zero (0) or more exception name patterns (for exceptions which must be a subclass of {@link Throwable}), indicating which exception types must cause a transaction rollback. &lt;p&gt;See the {@linkplain Transactional class-level javadocs} for further details on rollback rule semantics, patterns, and warnings regarding possible unintentional matches. @see rollbackFor @see org.springframework.transaction.interceptor.RollbackRuleAttributeRollbackRuleAttribute(String) @see org.springframework.transaction.interceptor.DefaultTransactionAttributerollbackOn(Throwable) String[] rollbackForClassName() default {}; Defines zero (0) or more exception {@link Class Classes}, which must be subclasses of {@link Throwable}, indicating which exception types must &lt;b&gt;not&lt;b&gt; cause a transaction rollback. &lt;p&gt;This is the preferred way to construct a rollback rule (in contrast to {@link noRollbackForClassName}), matching the exception type, its subclasses, and its nested classes. See the {@linkplain Transactional class-level javadocs} for further details on rollback rule semantics and warnings regarding possible unintentional matches. @see noRollbackForClassName @see org.springframework.transaction.interceptor.NoRollbackRuleAttributeNoRollbackRuleAttribute(Class) @see org.springframework.transaction.interceptor.DefaultTransactionAttributerollbackOn(Throwable) Class&lt;? extends Throwable&gt;[] noRollbackFor() default {}; Defines zero (0) or more exception name patterns (for exceptions which must be a subclass of {@link Throwable}) indicating which exception types must &lt;b&gt;not&lt;b&gt; cause a transaction rollback. &lt;p&gt;See the {@linkplain Transactional class-level javadocs} for further details on rollback rule semantics, patterns, and warnings regarding possible unintentional matches. @see noRollbackFor @see org.springframework.transaction.interceptor.NoRollbackRuleAttributeNoRollbackRuleAttribute(String) @see org.springframework.transaction.interceptor.DefaultTransactionAttributerollbackOn(Throwable) String[] noRollbackForClassName() default {}; }" />
      <item value="Defines zero (0) or more exception name patterns (for exceptions which must be a subclass of {@link Throwable}), indicating which exception types must cause a transaction rollback. &lt;p&gt;See the {@linkplain Transactional class-level javadocs} for further details on rollback rule semantics, patterns, and warnings regarding possible unintentional matches." />
      <item value="折线图" />
      <item value="the maxHistory property is given to TimeBasedRollingPolicy instead of to the TimeBasedFileNamingAndTriggeringPolicy. This makes it more convenient for the user at the cost of inconsistency here." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="89" />
        <entry key="ENGLISH" value="90" />
        <entry key="HINDI" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1678183553317" />
  </component>
</application>