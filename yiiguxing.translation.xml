<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="306" />
    <option name="newTranslationDialogWidth" value="509" />
    <option name="newTranslationDialogX" value="1356" />
    <option name="newTranslationDialogY" value="149" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Iterate over a copy to allow for init methods which in turn register new bean definitions. While this may not be part of the regular factory bootstrap, it does otherwise work fine." />
      <item value="Allow for caching all bean definition metadata, not expecting further changes." />
      <item value="Stop using the temporary ClassLoader for type matching." />
      <item value="Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early." />
      <item value="Register a default embedded value resolver if no bean post-processor (such as a PropertyPlaceholderConfigurer bean) registered any before: at this point, primarily for resolution in annotation attribute values." />
      <item value="Initialize conversion service for this context." />
      <item value="Instantiate all remaining (non-lazy-init) singletons." />
      <item value="Finish the initialization of this context's bean factory, initializing all remaining singleton beans." />
      <item value="Invoke factory processors registered as beans in the context." />
      <item value="Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime" />
      <item value="Register default environment beans." />
      <item value="Detect a LoadTimeWeaver and prepare for weaving, if found." />
      <item value="Register early post-processor for detecting inner beans as ApplicationListeners." />
      <item value="Create a new {@code StandardBeanExpressionResolver} with the given bean class loader, using it as the basis for expression compilation." />
      <item value="Configure the factory's standard context characteristics, such as the context's ClassLoader and post-processors." />
      <item value="Get the role hint for this {@code BeanDefinition}. The role hint provides the frameworks as well as tools with an indication of the role and importance of a particular {@code BeanDefinition}." />
      <item value="frozen" />
      <item value="Create the {@link XmlReaderContext} to pass over to the document reader." />
      <item value="reading bean definitions from an XML document." />
      <item value="Take an array of strings and split each element based on the given delimiter. A {@code Properties} instance is then generated, with the left of the delimiter providing the key, and the right of the delimiter providing the value." />
      <item value="Convert a comma delimited list (e.g., a row from a CSV file) into an array of strings." />
      <item value="System property that instructs Spring to ignore system environment variables," />
      <item value="Inherit Environment if possible" />
      <item value="Determine whether the given bean name is already in use within this registry,&#10;&#9; * i.e. whether there is a local bean or alias registered under this name." />
      <item value=" Return the names of all beans defined in this registry." />
      <item value="Return the BeanDefinition for the given bean name." />
      <item value="Remove the BeanDefinition for the given name." />
      <item value="Register a new bean definition with this registry. Must support RootBeanDefinition and ChildBeanDefinition." />
      <item value="Standalone XML application context, taking the context definition files from the class path, interpreting plain paths as class path resource names that include the package path (e.g. &quot;mypackagemyresource.txt&quot;). Useful for test harnesses as well as for application contexts embedded within JARs." />
      <item value="Read bean definitions from the given DOM document and register them with the registry in the given reader context." />
      <item value="Resolve the given location against the given resource loader if this implementation's protocol matches." />
      <item value="Any nested &lt;beans&gt; elements will cause recursion in this method. In order to propagate and preserve &lt;beans&gt; default- attributes correctly, keep track of the current (parent) delegate, which may be null. Create the new (child) delegate with a reference to the parent for fallback purposes, then ultimately reset this.delegate back to its original (parent) reference. this behavior emulates a stack of delegates without actually necessitating one." />
      <item value="Actually load the specified document using the configured DocumentLoader." />
      <item value="the number of bean definitions found" />
      <item value="a single resource with the given name" />
      <item value="Load the bean definitions with the given XmlBeanDefinitionReader." />
      <item value="Load bean definitions into the given bean factory, typically through delegating to one or more bean definition readers." />
      <item value="Configure the bean definition reader with this context's resource loading environment." />
      <item value="Configuration interface to be implemented by most listable bean factories. In addition to {@link ConfigurableBeanFactory}, it provides facilities to analyze and modify bean definitions, and to pre-instantiate singletons." />
      <item value="Validate that all properties marked as required are resolvable: see ConfigurablePropertyResolversetRequiredProperties" />
      <item value="This method is idempotent with respect to the fact it may be called any number of times but will perform replacement of stub property sources with their corresponding actual property sources once and only once." />
      <item value="JSON" />
      <item value="@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest)request; HttpSession ses = req.getSession(); HttpServletResponse resp = (HttpServletResponse)response; String path = req.getContextPath(); req.setCharacterEncoding(&quot;UTF-8&quot;); 登陆放通 if (LoginVerify.isLogin(req)) { chain.doFilter(request, response); return; } String url = req.getRequestURI(); System.out.println(url); 不需要拦截的请求 List&lt;String&gt; filterPath = Lists.newArrayList(); filterPath.add(path + &quot;login&quot;); filterPath.add(path + &quot;register&quot;); filterPath.add(path + &quot;userregister.jsp&quot;); filterPath.add(path + &quot;userlogin.jsp&quot;); filterPath.add(path + &quot;error.jsp&quot;); 没有登陆 路径为空-&gt;跳转登陆 if (StringUtils.isEmpty(url)) {" />
      <item value="Nullable" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2" />
        <entry key="ENGLISH" value="4" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1621517925835" />
  </component>
</application>